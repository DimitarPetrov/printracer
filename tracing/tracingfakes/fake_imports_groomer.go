// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"go/ast"
	"go/token"
	"io"
	"sync"

	"github.com/DimitarPetrov/printracer/tracing"
)

type FakeImportsGroomer struct {
	RemoveUnusedImportFromDirectoryStub        func(string, string) error
	removeUnusedImportFromDirectoryMutex       sync.RWMutex
	removeUnusedImportFromDirectoryArgsForCall []struct {
		arg1 string
		arg2 string
	}
	removeUnusedImportFromDirectoryReturns struct {
		result1 error
	}
	removeUnusedImportFromDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveUnusedImportFromFileStub        func(*token.FileSet, *ast.File, io.Writer, string) error
	removeUnusedImportFromFileMutex       sync.RWMutex
	removeUnusedImportFromFileArgsForCall []struct {
		arg1 *token.FileSet
		arg2 *ast.File
		arg3 io.Writer
		arg4 string
	}
	removeUnusedImportFromFileReturns struct {
		result1 error
	}
	removeUnusedImportFromFileReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveUnusedImportFromPackageStub        func(*token.FileSet, *ast.Package, string) error
	removeUnusedImportFromPackageMutex       sync.RWMutex
	removeUnusedImportFromPackageArgsForCall []struct {
		arg1 *token.FileSet
		arg2 *ast.Package
		arg3 string
	}
	removeUnusedImportFromPackageReturns struct {
		result1 error
	}
	removeUnusedImportFromPackageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectory(arg1 string, arg2 string) error {
	fake.removeUnusedImportFromDirectoryMutex.Lock()
	ret, specificReturn := fake.removeUnusedImportFromDirectoryReturnsOnCall[len(fake.removeUnusedImportFromDirectoryArgsForCall)]
	fake.removeUnusedImportFromDirectoryArgsForCall = append(fake.removeUnusedImportFromDirectoryArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RemoveUnusedImportFromDirectory", []interface{}{arg1, arg2})
	fake.removeUnusedImportFromDirectoryMutex.Unlock()
	if fake.RemoveUnusedImportFromDirectoryStub != nil {
		return fake.RemoveUnusedImportFromDirectoryStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUnusedImportFromDirectoryReturns
	return fakeReturns.result1
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectoryCallCount() int {
	fake.removeUnusedImportFromDirectoryMutex.RLock()
	defer fake.removeUnusedImportFromDirectoryMutex.RUnlock()
	return len(fake.removeUnusedImportFromDirectoryArgsForCall)
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectoryCalls(stub func(string, string) error) {
	fake.removeUnusedImportFromDirectoryMutex.Lock()
	defer fake.removeUnusedImportFromDirectoryMutex.Unlock()
	fake.RemoveUnusedImportFromDirectoryStub = stub
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectoryArgsForCall(i int) (string, string) {
	fake.removeUnusedImportFromDirectoryMutex.RLock()
	defer fake.removeUnusedImportFromDirectoryMutex.RUnlock()
	argsForCall := fake.removeUnusedImportFromDirectoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectoryReturns(result1 error) {
	fake.removeUnusedImportFromDirectoryMutex.Lock()
	defer fake.removeUnusedImportFromDirectoryMutex.Unlock()
	fake.RemoveUnusedImportFromDirectoryStub = nil
	fake.removeUnusedImportFromDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromDirectoryReturnsOnCall(i int, result1 error) {
	fake.removeUnusedImportFromDirectoryMutex.Lock()
	defer fake.removeUnusedImportFromDirectoryMutex.Unlock()
	fake.RemoveUnusedImportFromDirectoryStub = nil
	if fake.removeUnusedImportFromDirectoryReturnsOnCall == nil {
		fake.removeUnusedImportFromDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUnusedImportFromDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFile(arg1 *token.FileSet, arg2 *ast.File, arg3 io.Writer, arg4 string) error {
	fake.removeUnusedImportFromFileMutex.Lock()
	ret, specificReturn := fake.removeUnusedImportFromFileReturnsOnCall[len(fake.removeUnusedImportFromFileArgsForCall)]
	fake.removeUnusedImportFromFileArgsForCall = append(fake.removeUnusedImportFromFileArgsForCall, struct {
		arg1 *token.FileSet
		arg2 *ast.File
		arg3 io.Writer
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("RemoveUnusedImportFromFile", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeUnusedImportFromFileMutex.Unlock()
	if fake.RemoveUnusedImportFromFileStub != nil {
		return fake.RemoveUnusedImportFromFileStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUnusedImportFromFileReturns
	return fakeReturns.result1
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFileCallCount() int {
	fake.removeUnusedImportFromFileMutex.RLock()
	defer fake.removeUnusedImportFromFileMutex.RUnlock()
	return len(fake.removeUnusedImportFromFileArgsForCall)
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFileCalls(stub func(*token.FileSet, *ast.File, io.Writer, string) error) {
	fake.removeUnusedImportFromFileMutex.Lock()
	defer fake.removeUnusedImportFromFileMutex.Unlock()
	fake.RemoveUnusedImportFromFileStub = stub
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFileArgsForCall(i int) (*token.FileSet, *ast.File, io.Writer, string) {
	fake.removeUnusedImportFromFileMutex.RLock()
	defer fake.removeUnusedImportFromFileMutex.RUnlock()
	argsForCall := fake.removeUnusedImportFromFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFileReturns(result1 error) {
	fake.removeUnusedImportFromFileMutex.Lock()
	defer fake.removeUnusedImportFromFileMutex.Unlock()
	fake.RemoveUnusedImportFromFileStub = nil
	fake.removeUnusedImportFromFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromFileReturnsOnCall(i int, result1 error) {
	fake.removeUnusedImportFromFileMutex.Lock()
	defer fake.removeUnusedImportFromFileMutex.Unlock()
	fake.RemoveUnusedImportFromFileStub = nil
	if fake.removeUnusedImportFromFileReturnsOnCall == nil {
		fake.removeUnusedImportFromFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUnusedImportFromFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackage(arg1 *token.FileSet, arg2 *ast.Package, arg3 string) error {
	fake.removeUnusedImportFromPackageMutex.Lock()
	ret, specificReturn := fake.removeUnusedImportFromPackageReturnsOnCall[len(fake.removeUnusedImportFromPackageArgsForCall)]
	fake.removeUnusedImportFromPackageArgsForCall = append(fake.removeUnusedImportFromPackageArgsForCall, struct {
		arg1 *token.FileSet
		arg2 *ast.Package
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveUnusedImportFromPackage", []interface{}{arg1, arg2, arg3})
	fake.removeUnusedImportFromPackageMutex.Unlock()
	if fake.RemoveUnusedImportFromPackageStub != nil {
		return fake.RemoveUnusedImportFromPackageStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUnusedImportFromPackageReturns
	return fakeReturns.result1
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackageCallCount() int {
	fake.removeUnusedImportFromPackageMutex.RLock()
	defer fake.removeUnusedImportFromPackageMutex.RUnlock()
	return len(fake.removeUnusedImportFromPackageArgsForCall)
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackageCalls(stub func(*token.FileSet, *ast.Package, string) error) {
	fake.removeUnusedImportFromPackageMutex.Lock()
	defer fake.removeUnusedImportFromPackageMutex.Unlock()
	fake.RemoveUnusedImportFromPackageStub = stub
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackageArgsForCall(i int) (*token.FileSet, *ast.Package, string) {
	fake.removeUnusedImportFromPackageMutex.RLock()
	defer fake.removeUnusedImportFromPackageMutex.RUnlock()
	argsForCall := fake.removeUnusedImportFromPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackageReturns(result1 error) {
	fake.removeUnusedImportFromPackageMutex.Lock()
	defer fake.removeUnusedImportFromPackageMutex.Unlock()
	fake.RemoveUnusedImportFromPackageStub = nil
	fake.removeUnusedImportFromPackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) RemoveUnusedImportFromPackageReturnsOnCall(i int, result1 error) {
	fake.removeUnusedImportFromPackageMutex.Lock()
	defer fake.removeUnusedImportFromPackageMutex.Unlock()
	fake.RemoveUnusedImportFromPackageStub = nil
	if fake.removeUnusedImportFromPackageReturnsOnCall == nil {
		fake.removeUnusedImportFromPackageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUnusedImportFromPackageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImportsGroomer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.removeUnusedImportFromDirectoryMutex.RLock()
	defer fake.removeUnusedImportFromDirectoryMutex.RUnlock()
	fake.removeUnusedImportFromFileMutex.RLock()
	defer fake.removeUnusedImportFromFileMutex.RUnlock()
	fake.removeUnusedImportFromPackageMutex.RLock()
	defer fake.removeUnusedImportFromPackageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImportsGroomer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tracing.ImportsGroomer = new(FakeImportsGroomer)
