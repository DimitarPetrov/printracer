// Code generated by counterfeiter. DO NOT EDIT.
package tracingfakes

import (
	"go/ast"
	"go/token"
	"io"
	"sync"

	"github.com/DimitarPetrov/printracer/tracing"
)

type FakeCodeInstrumenter struct {
	InstrumentDirectoryStub        func(string) error
	instrumentDirectoryMutex       sync.RWMutex
	instrumentDirectoryArgsForCall []struct {
		arg1 string
	}
	instrumentDirectoryReturns struct {
		result1 error
	}
	instrumentDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	InstrumentFileStub        func(*token.FileSet, *ast.File, io.Writer) error
	instrumentFileMutex       sync.RWMutex
	instrumentFileArgsForCall []struct {
		arg1 *token.FileSet
		arg2 *ast.File
		arg3 io.Writer
	}
	instrumentFileReturns struct {
		result1 error
	}
	instrumentFileReturnsOnCall map[int]struct {
		result1 error
	}
	InstrumentPackageStub        func(*token.FileSet, *ast.Package) error
	instrumentPackageMutex       sync.RWMutex
	instrumentPackageArgsForCall []struct {
		arg1 *token.FileSet
		arg2 *ast.Package
	}
	instrumentPackageReturns struct {
		result1 error
	}
	instrumentPackageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCodeInstrumenter) InstrumentDirectory(arg1 string) error {
	fake.instrumentDirectoryMutex.Lock()
	ret, specificReturn := fake.instrumentDirectoryReturnsOnCall[len(fake.instrumentDirectoryArgsForCall)]
	fake.instrumentDirectoryArgsForCall = append(fake.instrumentDirectoryArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("InstrumentDirectory", []interface{}{arg1})
	fake.instrumentDirectoryMutex.Unlock()
	if fake.InstrumentDirectoryStub != nil {
		return fake.InstrumentDirectoryStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.instrumentDirectoryReturns
	return fakeReturns.result1
}

func (fake *FakeCodeInstrumenter) InstrumentDirectoryCallCount() int {
	fake.instrumentDirectoryMutex.RLock()
	defer fake.instrumentDirectoryMutex.RUnlock()
	return len(fake.instrumentDirectoryArgsForCall)
}

func (fake *FakeCodeInstrumenter) InstrumentDirectoryCalls(stub func(string) error) {
	fake.instrumentDirectoryMutex.Lock()
	defer fake.instrumentDirectoryMutex.Unlock()
	fake.InstrumentDirectoryStub = stub
}

func (fake *FakeCodeInstrumenter) InstrumentDirectoryArgsForCall(i int) string {
	fake.instrumentDirectoryMutex.RLock()
	defer fake.instrumentDirectoryMutex.RUnlock()
	argsForCall := fake.instrumentDirectoryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCodeInstrumenter) InstrumentDirectoryReturns(result1 error) {
	fake.instrumentDirectoryMutex.Lock()
	defer fake.instrumentDirectoryMutex.Unlock()
	fake.InstrumentDirectoryStub = nil
	fake.instrumentDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) InstrumentDirectoryReturnsOnCall(i int, result1 error) {
	fake.instrumentDirectoryMutex.Lock()
	defer fake.instrumentDirectoryMutex.Unlock()
	fake.InstrumentDirectoryStub = nil
	if fake.instrumentDirectoryReturnsOnCall == nil {
		fake.instrumentDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.instrumentDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) InstrumentFile(arg1 *token.FileSet, arg2 *ast.File, arg3 io.Writer) error {
	fake.instrumentFileMutex.Lock()
	ret, specificReturn := fake.instrumentFileReturnsOnCall[len(fake.instrumentFileArgsForCall)]
	fake.instrumentFileArgsForCall = append(fake.instrumentFileArgsForCall, struct {
		arg1 *token.FileSet
		arg2 *ast.File
		arg3 io.Writer
	}{arg1, arg2, arg3})
	fake.recordInvocation("InstrumentFile", []interface{}{arg1, arg2, arg3})
	fake.instrumentFileMutex.Unlock()
	if fake.InstrumentFileStub != nil {
		return fake.InstrumentFileStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.instrumentFileReturns
	return fakeReturns.result1
}

func (fake *FakeCodeInstrumenter) InstrumentFileCallCount() int {
	fake.instrumentFileMutex.RLock()
	defer fake.instrumentFileMutex.RUnlock()
	return len(fake.instrumentFileArgsForCall)
}

func (fake *FakeCodeInstrumenter) InstrumentFileCalls(stub func(*token.FileSet, *ast.File, io.Writer) error) {
	fake.instrumentFileMutex.Lock()
	defer fake.instrumentFileMutex.Unlock()
	fake.InstrumentFileStub = stub
}

func (fake *FakeCodeInstrumenter) InstrumentFileArgsForCall(i int) (*token.FileSet, *ast.File, io.Writer) {
	fake.instrumentFileMutex.RLock()
	defer fake.instrumentFileMutex.RUnlock()
	argsForCall := fake.instrumentFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCodeInstrumenter) InstrumentFileReturns(result1 error) {
	fake.instrumentFileMutex.Lock()
	defer fake.instrumentFileMutex.Unlock()
	fake.InstrumentFileStub = nil
	fake.instrumentFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) InstrumentFileReturnsOnCall(i int, result1 error) {
	fake.instrumentFileMutex.Lock()
	defer fake.instrumentFileMutex.Unlock()
	fake.InstrumentFileStub = nil
	if fake.instrumentFileReturnsOnCall == nil {
		fake.instrumentFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.instrumentFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) InstrumentPackage(arg1 *token.FileSet, arg2 *ast.Package) error {
	fake.instrumentPackageMutex.Lock()
	ret, specificReturn := fake.instrumentPackageReturnsOnCall[len(fake.instrumentPackageArgsForCall)]
	fake.instrumentPackageArgsForCall = append(fake.instrumentPackageArgsForCall, struct {
		arg1 *token.FileSet
		arg2 *ast.Package
	}{arg1, arg2})
	fake.recordInvocation("InstrumentPackage", []interface{}{arg1, arg2})
	fake.instrumentPackageMutex.Unlock()
	if fake.InstrumentPackageStub != nil {
		return fake.InstrumentPackageStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.instrumentPackageReturns
	return fakeReturns.result1
}

func (fake *FakeCodeInstrumenter) InstrumentPackageCallCount() int {
	fake.instrumentPackageMutex.RLock()
	defer fake.instrumentPackageMutex.RUnlock()
	return len(fake.instrumentPackageArgsForCall)
}

func (fake *FakeCodeInstrumenter) InstrumentPackageCalls(stub func(*token.FileSet, *ast.Package) error) {
	fake.instrumentPackageMutex.Lock()
	defer fake.instrumentPackageMutex.Unlock()
	fake.InstrumentPackageStub = stub
}

func (fake *FakeCodeInstrumenter) InstrumentPackageArgsForCall(i int) (*token.FileSet, *ast.Package) {
	fake.instrumentPackageMutex.RLock()
	defer fake.instrumentPackageMutex.RUnlock()
	argsForCall := fake.instrumentPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCodeInstrumenter) InstrumentPackageReturns(result1 error) {
	fake.instrumentPackageMutex.Lock()
	defer fake.instrumentPackageMutex.Unlock()
	fake.InstrumentPackageStub = nil
	fake.instrumentPackageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) InstrumentPackageReturnsOnCall(i int, result1 error) {
	fake.instrumentPackageMutex.Lock()
	defer fake.instrumentPackageMutex.Unlock()
	fake.InstrumentPackageStub = nil
	if fake.instrumentPackageReturnsOnCall == nil {
		fake.instrumentPackageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.instrumentPackageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCodeInstrumenter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.instrumentDirectoryMutex.RLock()
	defer fake.instrumentDirectoryMutex.RUnlock()
	fake.instrumentFileMutex.RLock()
	defer fake.instrumentFileMutex.RUnlock()
	fake.instrumentPackageMutex.RLock()
	defer fake.instrumentPackageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCodeInstrumenter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ tracing.CodeInstrumenter = new(FakeCodeInstrumenter)
